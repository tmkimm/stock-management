package com.tmkim.stock.service.stream;

import org.junit.Test;

public class Lambda {
    // 람다란 함수를 하나의 식으로 표현한 것
    // 메소드의 이름이 없기때문에 익명 함수의 종류다.

    // 장점
    // 1. 코드가 간결해진다.
    // 2. 식에 개발자의 의도가 명확히 드러나 가독성이 좋아진다.
    // 함수를 만드는 과정 없이 처리할 수 있어 생산성이 높아진다.

    // 단점
    // 1. 재사용 불가능
    // 2. 디버깅 어려움
    // 3. 비슷한 함수가 중복 생성되어 코드가 지저분

    // 일반적인 메소드
    public String hello() {
        return "Hello World!";
    }

    // 람다식
    // () -> "Hello world!";

    // 처음 보고 충격이었음. 모든게 클래스 기반인 자바에서 어떻게 이런게 가능하지? 내부적으로 어떻게 자동하는걸까?
    // 람다식의 실체는 메서드가 아닌 익명 클래스의 객체다.
    //     (int a, int b) -> a < b ? a : b;
    // equal
    //    new Object() {
    //        int max(int a, int b) {
    //            return a > b ? a : b;
    //        }
    //    }
    // 람다식은 메소드같지만 사실은 익명 클래스의 인스턴스를 넘기는 것이다.

    // 람다식으로 생성된 메소드는 함수형 인터페이스로만 선언이 가능하다.
    // 함수형 인터페이스란?
    // 추상 메소드를 하나만 갖는 인터페이스이다. 단 하나의 추상 메소드만을 갖도록 제한하는 역할이다.

    // 이런 이상해보이는 함수형 인터페이스가 왜 필요하지?
    // 함수형 인터페이스는 제목만 있는 기능명세서와 같다.
    // 구체적인 내용은 없지만, 제목을 보고 개발자는 어떤 기능을 구현해야 하는지 알 수 있다.
    // 어떤 방식으로 구현을 할지는 개발자의 마음이고 해당 기능만 구현하면 된다.

    // 함수형 인터페이스의 역할이 바로 이것이다.
    // 구현해야 하는 기능을 제한함으로써 다른 기능을 만드는걸 방지할 수 있고 클라이언트(다른 메소드)에게 어떤 기능을 사용하면 될지 알려준다.

    /*
    @FunctionalInterface
    public interface Runnable {
        public abstract void run();
    }
     */

    // 람다식으로 생성된 메소드는 함수형 인터페이스로만 선언이 가능하다고 했다.
    // 람다는 메소드 이름이 없는 함수이기 때문에 어떻게 호출해야 하는지 알 수 없고 람다만으로는 타입을 알 수 없다.
    // 그래서 람다는 함수형 인터페이스로만 선언이 가능하다.
    // (int a, int b) -> a < b ? a : b;

    // 자바에서는 자주 사용되는 여러 함수형 인터페이스를 제공해준다.
    // Supplier<T>
    // Consumer<T>
    // Function<T, R>



}

